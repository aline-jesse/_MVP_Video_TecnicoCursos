
'use client';

import React, { useState, useCallback } from 'react';
import { useDropzone } from 'react-dropzone';
import { CircularProgressbar } from 'react-circular-progressbar';
import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
import { Upload, X, FileText, AlertCircle, CheckCircle } from 'lucide-react';
import { Card, CardContent } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Progress } from '@/components/ui/progress';
import { Alert, AlertDescription } from '@/components/ui/alert';
import toast from 'react-hot-toast';
import 'react-circular-progressbar/dist/styles.css';

interface UploadFile {
  id: string;
  file: File;
  progress: number;
  status: 'pending' | 'uploading' | 'processing' | 'completed' | 'error';
  error?: string;
  s3Key?: string;
  previewUrl?: string;
  processedData?: any;
}

interface ProductionPPTXUploadProps {
  onUploadComplete?: (data: any) => void;
  maxFileSize?: number; // in MB
  maxFiles?: number;
  allowedTypes?: string[];
}

const ProductionPPTXUpload: React.FC<ProductionPPTXUploadProps> = ({
  onUploadComplete,
  maxFileSize = 100, // 100MB por padrão
  maxFiles = 5,
  allowedTypes = [
    'application/vnd.openxmlformats-officedocument.presentationml.presentation',
    'application/vnd.ms-powerpoint',
    '.pptx',
    '.ppt'
  ]
}) => {
  const [uploadFiles, setUploadFiles] = useState<UploadFile[]>([]);
  const [isUploading, setIsUploading] = useState(false);

  // Configuração do S3 Client
  const s3Client = new S3Client({
    region: process.env.NEXT_PUBLIC_AWS_REGION || 'us-east-1',
    credentials: {
      accessKeyId: process.env.NEXT_PUBLIC_AWS_ACCESS_KEY_ID || '',
      secretAccessKey: process.env.NEXT_PUBLIC_AWS_SECRET_ACCESS_KEY || ''
    }
  });

  // Validação de arquivo
  const validateFile = (file: File): string | null => {
    // Verificar tamanho
    if (file.size > maxFileSize * 1024 * 1024) {
      return `Arquivo muito grande. Tamanho máximo: ${maxFileSize}MB`;
    }

    // Verificar tipo MIME
    const isValidType = allowedTypes.some(type => 
      file.type === type || file.name.toLowerCase().endsWith(type.replace('.', ''))
    );

    if (!isValidType) {
      return 'Tipo de arquivo não suportado. Apenas arquivos PowerPoint (.pptx, .ppt)';
    }

    // Verificar extensão
    const extension = file.name.toLowerCase().split('.').pop();
    if (!extension || !['pptx', 'ppt'].includes(extension)) {
      return 'Extensão de arquivo inválida';
    }

    return null;
  };

  // Upload para S3 com retry mechanism
  const uploadToS3 = async (file: File, onProgress: (progress: number) => void): Promise<string> => {
    const key = `pptx-uploads/${Date.now()}-${file.name}`;
    let retryCount = 0;
    const maxRetries = 3;

    while (retryCount < maxRetries) {
      try {
        // Simular progresso (em produção, usar multipart upload para arquivos grandes)
        const uploadProgress = setInterval(() => {
          onProgress(Math.min(95, Math.random() * 90 + 10));
        }, 200);

        const command = new PutObjectCommand({
          Bucket: process.env.NEXT_PUBLIC_AWS_BUCKET_NAME || 'estudio-ia-videos',
          Key: key,
          Body: file,
          ContentType: file.type,
          Metadata: {
            originalName: file.name,
            uploadedAt: new Date().toISOString(),
          }
        });

        await s3Client.send(command);
        clearInterval(uploadProgress);
        onProgress(100);
        
        return key;
      } catch (error) {
        retryCount++;
        if (retryCount === maxRetries) {
          throw new Error(`Falha no upload após ${maxRetries} tentativas: ${error}`);
        }
        // Aguardar antes da próxima tentativa
        await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
      }
    }

    throw new Error('Upload falhou');
  };

  // Processar arquivo PPTX
  const processFile = async (file: File, s3Key: string): Promise<any> => {
    try {
      const formData = new FormData();
      formData.append('file', file);
      formData.append('s3Key', s3Key);

      const response = await fetch('/api/v1/pptx/enhanced-process', {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        throw new Error(`Erro no processamento: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      throw new Error(`Falha no processamento: ${error}`);
    }
  };

  // Gerar thumbnail de preview
  const generatePreview = async (file: File): Promise<string> => {
    return new Promise((resolve) => {
      const reader = new FileReader();
      reader.onload = () => {
        // Em produção, usar uma biblioteca para gerar thumbnail real do PPTX
        resolve('/images/pptx-placeholder.png');
      };
      reader.readAsDataURL(file);
    });
  };

  // Processar upload completo
  const handleFileUpload = async (file: File) => {
    const uploadId = Date.now().toString() + Math.random().toString(36).substr(2, 9);
    
    const uploadFile: UploadFile = {
      id: uploadId,
      file,
      progress: 0,
      status: 'pending'
    };

    setUploadFiles(prev => [...prev, uploadFile]);

    try {
      // 1. Gerar preview
      uploadFile.previewUrl = await generatePreview(file);
      updateUploadFile(uploadId, { previewUrl: uploadFile.previewUrl });

      // 2. Upload para S3
      uploadFile.status = 'uploading';
      updateUploadFile(uploadId, { status: 'uploading' });

      const s3Key = await uploadToS3(file, (progress) => {
        updateUploadFile(uploadId, { progress });
      });

      uploadFile.s3Key = s3Key;
      updateUploadFile(uploadId, { s3Key, progress: 100 });

      // 3. Processar arquivo
      uploadFile.status = 'processing';
      updateUploadFile(uploadId, { status: 'processing' });

      const processedData = await processFile(file, s3Key);
      
      uploadFile.processedData = processedData;
      uploadFile.status = 'completed';
      updateUploadFile(uploadId, { 
        processedData, 
        status: 'completed' 
      });

      toast.success(`${file.name} processado com sucesso!`);
      
      if (onUploadComplete) {
        onUploadComplete(processedData);
      }

    } catch (error) {
      uploadFile.status = 'error';
      uploadFile.error = error instanceof Error ? error.message : 'Erro desconhecido';
      updateUploadFile(uploadId, { 
        status: 'error', 
        error: uploadFile.error 
      });

      toast.error(`Erro ao processar ${file.name}: ${uploadFile.error}`);
    }
  };

  // Atualizar estado do arquivo
  const updateUploadFile = (id: string, updates: Partial<UploadFile>) => {
    setUploadFiles(prev => 
      prev.map(file => 
        file.id === id ? { ...file, ...updates } : file
      )
    );
  };

  // Remover arquivo
  const removeFile = (id: string) => {
    setUploadFiles(prev => prev.filter(file => file.id !== id));
  };

  // Handler do dropzone
  const onDrop = useCallback(async (acceptedFiles: File[]) => {
    if (uploadFiles.length + acceptedFiles.length > maxFiles) {
      toast.error(`Máximo de ${maxFiles} arquivos permitidos`);
      return;
    }

    setIsUploading(true);

    for (const file of acceptedFiles) {
      const validation = validateFile(file);
      if (validation) {
        toast.error(`${file.name}: ${validation}`);
        continue;
      }

      await handleFileUpload(file);
    }

    setIsUploading(false);
  }, [uploadFiles, maxFiles]);

  // Configuração do dropzone
  const { getRootProps, getInputProps, isDragActive, fileRejections } = useDropzone({
    onDrop,
    accept: {
      'application/vnd.openxmlformats-officedocument.presentationml.presentation': ['.pptx'],
      'application/vnd.ms-powerpoint': ['.ppt']
    },
    maxSize: maxFileSize * 1024 * 1024,
    maxFiles,
    disabled: isUploading
  });

  // Renderizar status do arquivo
  const renderFileStatus = (file: UploadFile) => {
    switch (file.status) {
      case 'uploading':
        return (
          <div className="flex items-center space-x-2">
            <div className="w-8 h-8">
              <CircularProgressbar 
                value={file.progress} 
                text={`${Math.round(file.progress)}%`}
                styles={{
                  text: { fontSize: '14px', fill: '#3b82f6' },
                  path: { stroke: '#3b82f6' }
                }}
              />
            </div>
            <span className="text-blue-600">Enviando...</span>
          </div>
        );

      case 'processing':
        return (
          <div className="flex items-center space-x-2">
            <div className="animate-spin rounded-full h-6 w-6 border-2 border-blue-600 border-t-transparent"></div>
            <span className="text-blue-600">Processando...</span>
          </div>
        );

      case 'completed':
        return (
          <div className="flex items-center space-x-2">
            <CheckCircle className="w-6 h-6 text-green-600" />
            <span className="text-green-600">Concluído</span>
          </div>
        );

      case 'error':
        return (
          <div className="flex items-center space-x-2">
            <AlertCircle className="w-6 h-6 text-red-600" />
            <span className="text-red-600 text-sm">{file.error}</span>
          </div>
        );

      default:
        return (
          <div className="flex items-center space-x-2">
            <FileText className="w-6 h-6 text-gray-400" />
            <span className="text-gray-600">Aguardando...</span>
          </div>
        );
    }
  };

  return (
    <div className="space-y-6">
      {/* Drop Zone */}
      <div
        {...getRootProps()}
        className={`
          border-2 border-dashed rounded-lg p-8 text-center cursor-pointer transition-colors
          ${isDragActive ? 'border-blue-500 bg-blue-50' : 'border-gray-300 hover:border-blue-400'}
          ${isUploading ? 'pointer-events-none opacity-50' : ''}
        `}
      >
        <input {...getInputProps()} />
        <Upload className="w-12 h-12 mx-auto mb-4 text-gray-400" />
        
        {isDragActive ? (
          <p className="text-blue-600 text-lg font-medium">
            Solte os arquivos aqui...
          </p>
        ) : (
          <div>
            <p className="text-gray-600 text-lg font-medium mb-2">
              Arraste arquivos PowerPoint aqui ou clique para selecionar
            </p>
            <p className="text-gray-400 text-sm">
              Suporta .pptx e .ppt até {maxFileSize}MB • Máximo {maxFiles} arquivos
            </p>
          </div>
        )}
      </div>

      {/* Arquivos Rejeitados */}
      {fileRejections.length > 0 && (
        <Alert>
          <AlertCircle className="h-4 w-4" />
          <AlertDescription>
            Alguns arquivos foram rejeitados: {fileRejections.map((rejection: any) => rejection.file.name).join(', ')}
          </AlertDescription>
        </Alert>
      )}

      {/* Lista de Arquivos */}
      {uploadFiles.length > 0 && (
        <div className="space-y-4">
          <h3 className="text-lg font-semibold">Arquivos ({uploadFiles.length})</h3>
          
          {uploadFiles.map((file) => (
            <Card key={file.id} className="overflow-hidden">
              <CardContent className="p-4">
                <div className="flex items-center justify-between">
                  <div className="flex items-center space-x-3 flex-1">
                    {file.previewUrl && (
                      <img 
                        src={file.previewUrl} 
                        alt="Preview" 
                        className="w-12 h-12 object-cover rounded border"
                      />
                    )}
                    
                    <div className="flex-1">
                      <h4 className="font-medium text-sm">{file.file.name}</h4>
                      <p className="text-xs text-gray-500">
                        {(file.file.size / (1024 * 1024)).toFixed(2)} MB
                      </p>
                      
                      {file.status === 'uploading' && (
                        <Progress value={file.progress} className="mt-2" />
                      )}
                    </div>
                  </div>

                  <div className="flex items-center space-x-3">
                    {renderFileStatus(file)}
                    
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => removeFile(file.id)}
                      disabled={file.status === 'uploading' || file.status === 'processing'}
                    >
                      <X className="w-4 h-4" />
                    </Button>
                  </div>
                </div>
              </CardContent>
            </Card>
          ))}
        </div>
      )}

      {/* Estatísticas */}
      {uploadFiles.length > 0 && (
        <div className="bg-gray-50 rounded-lg p-4">
          <div className="grid grid-cols-4 gap-4 text-center">
            <div>
              <p className="text-2xl font-bold text-blue-600">
                {uploadFiles.filter(f => f.status === 'completed').length}
              </p>
              <p className="text-sm text-gray-600">Concluídos</p>
            </div>
            <div>
              <p className="text-2xl font-bold text-yellow-600">
                {uploadFiles.filter(f => f.status === 'uploading' || f.status === 'processing').length}
              </p>
              <p className="text-sm text-gray-600">Processando</p>
            </div>
            <div>
              <p className="text-2xl font-bold text-red-600">
                {uploadFiles.filter(f => f.status === 'error').length}
              </p>
              <p className="text-sm text-gray-600">Erros</p>
            </div>
            <div>
              <p className="text-2xl font-bold text-gray-600">
                {uploadFiles.length}
              </p>
              <p className="text-sm text-gray-600">Total</p>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default ProductionPPTXUpload;
