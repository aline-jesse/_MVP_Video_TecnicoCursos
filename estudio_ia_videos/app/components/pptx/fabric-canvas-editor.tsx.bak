

'use client'

/**
 * ðŸŽ¨ Fabric.js Canvas Editor - Professional Grade
 * Advanced canvas editing with layers, snap-to-grid, and export
 * Sprint 2 - Production Ready Implementation
 */

import React, { useEffect, useRef, useState, useCallback } from 'react'
import { fabric } from 'fabric'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Separator } from '@/components/ui/separator'
import { Badge } from '@/components/ui/badge'
import { Slider } from '@/components/ui/slider'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { toast } from 'react-hot-toast'
import { 
  Square, 
  Circle, 
  Type, 
  Image as ImageIcon,
  Layers,
  Grid,
  RotateCcw,
  RotateCw,
  Copy,
  Trash2,
  Download,
  ZoomIn,
  ZoomOut,
  Move,
  MousePointer2,
  Palette,
  Lock,
  Unlock,
  Eye,
  EyeOff,
  Plus,
  Minus,
  Save,
  FileText,
  Settings
} from 'lucide-react'

interface CanvasObject {
  id: string
  type: string
  name: string
  visible: boolean
  locked: boolean
  fabricObject: fabric.Object
}

interface FabricCanvasEditorProps {
  width?: number
  height?: number
  onCanvasUpdate?: (data: any) => void
  initialData?: any
  projectName?: string
}

export function FabricCanvasEditor({ 
  width = 800, 
  height = 600, 
  onCanvasUpdate,
  initialData,
  projectName = "Projeto Canvas"
}: FabricCanvasEditorProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const fabricCanvasRef = useRef<fabric.Canvas | null>(null)
  const fileInputRef = useRef<HTMLInputElement>(null)
  
  // State management
  const [selectedTool, setSelectedTool] = useState<string>('select')
  const [canvasObjects, setCanvasObjects] = useState<CanvasObject[]>([])
  const [selectedObjects, setSelectedObjects] = useState<string[]>([])
  const [zoom, setZoom] = useState<number[]>([100])
  const [snapToGrid, setSnapToGrid] = useState(false)
  const [gridSize, setGridSize] = useState(20)
  const [activeObject, setActiveObject] = useState<fabric.Object | null>(null)
  const [history, setHistory] = useState<any[]>([])
  const [historyIndex, setHistoryIndex] = useState(-1)
  const [canUndo, setCanUndo] = useState(false)
  const [canRedo, setCanRedo] = useState(false)

  // Tools configuration
  const tools = [
    { id: 'select', label: 'Selecionar', icon: MousePointer2 },
    { id: 'rect', label: 'RetÃ¢ngulo', icon: Square },
    { id: 'circle', label: 'CÃ­rculo', icon: Circle },
    { id: 'text', label: 'Texto', icon: Type },
    { id: 'image', label: 'Imagem', icon: ImageIcon },
    { id: 'move', label: 'Mover Canvas', icon: Move },
  ]

  // Initialize Fabric.js canvas
  useEffect(() => {
    if (!canvasRef.current || fabricCanvasRef.current) return
    
    const canvas = new fabric.Canvas(canvasRef.current, {
      width,
      height,
      backgroundColor: '#ffffff',
      selection: true,
      preserveObjectStacking: true,
      renderOnAddRemove: true,
      stateful: true,
    })
    
    fabricCanvasRef.current = canvas

    // Grid configuration
    if (snapToGrid) {
      const grid = gridSize
      canvas.on('object:moving', (e) => {
        const obj = e.target
        if (obj) {
          obj.set({
            left: Math.round((obj.left || 0) / grid) * grid,
            top: Math.round((obj.top || 0) / grid) * grid
          })
        }
      })
    }

    // Selection events
    canvas.on('selection:created', (e) => {
      const activeObj = canvas.getActiveObject()
      setActiveObject(activeObj)
      updateSelectedObjects(canvas)
    })

    canvas.on('selection:updated', (e) => {
      const activeObj = canvas.getActiveObject()
      setActiveObject(activeObj)
      updateSelectedObjects(canvas)
    })

    canvas.on('selection:cleared', () => {
      setActiveObject(null)
      setSelectedObjects([])
    })

    // History tracking
    canvas.on('object:added', () => saveCanvasState(canvas))
    canvas.on('object:removed', () => saveCanvasState(canvas))
    canvas.on('object:modified', () => saveCanvasState(canvas))

    // Load initial data
    if (initialData) {
      canvas.loadFromJSON(initialData, () => {
        canvas.renderAll()
        updateObjectsList(canvas)
      })
    }

    updateObjectsList(canvas)

    return () => {
      canvas.dispose()
    }
  }, [width, height, snapToGrid, gridSize, initialData])

  // Update objects list
  const updateObjectsList = (canvas: fabric.Canvas) => {
    const objects = canvas.getObjects().map((obj, index) => ({
      id: obj.id || `object-${index}`,
      type: obj.type || 'unknown',
      name: (obj as any).name || `${obj.type || 'Object'} ${index + 1}`,
      visible: obj.visible !== false,
      locked: obj.selectable === false,
      fabricObject: obj
    }))
    setCanvasObjects(objects)
  }

  // Update selected objects
  const updateSelectedObjects = (canvas: fabric.Canvas) => {
    const activeObj = canvas.getActiveObject()
    if (activeObj) {
      if (activeObj.type === 'activeSelection') {
        const selection = activeObj as fabric.ActiveSelection
        const ids = selection.getObjects().map((obj, index) => obj.id || `object-${index}`)
        setSelectedObjects(ids)
      } else {
        setSelectedObjects([activeObj.id || 'unknown'])
      }
    } else {
      setSelectedObjects([])
    }
  }

  // Canvas state management
  const saveCanvasState = useCallback((canvas: fabric.Canvas) => {
    const state = JSON.stringify(canvas.toJSON())
    setHistory(prev => {
      const newHistory = prev.slice(0, historyIndex + 1)
      newHistory.push(state)
      return newHistory.slice(-50) // Keep only last 50 states
    })
    setHistoryIndex(prev => prev + 1)
    setCanUndo(true)
    setCanRedo(false)
    
    if (onCanvasUpdate) {
      onCanvasUpdate(canvas.toJSON())
    }
  }, [historyIndex, onCanvasUpdate])

  // Tool functions
  const addRectangle = () => {
    const canvas = fabricCanvasRef.current
    if (!canvas) return

    const rect = new fabric.Rect({
      left: 100,
      top: 100,
      width: 200,
      height: 100,
      fill: '#3b82f6',
      stroke: '#1e40af',
      strokeWidth: 2,
      id: `rect-${Date.now()}`
    } as any)

    canvas.add(rect)
    canvas.setActiveObject(rect)
    updateObjectsList(canvas)
    toast.success('RetÃ¢ngulo adicionado!')
  }

  const addCircle = () => {
    const canvas = fabricCanvasRef.current
    if (!canvas) return

    const circle = new fabric.Circle({
      left: 150,
      top: 150,
      radius: 50,
      fill: '#10b981',
      stroke: '#059669',
      strokeWidth: 2,
      id: `circle-${Date.now()}`
    } as any)

    canvas.add(circle)
    canvas.setActiveObject(circle)
    updateObjectsList(canvas)
    toast.success('CÃ­rculo adicionado!')
  }

  const addText = () => {
    const canvas = fabricCanvasRef.current
    if (!canvas) return

    const text = new fabric.Text('Novo Texto', {
      left: 200,
      top: 200,
      fontSize: 24,
      fill: '#1f2937',
      fontFamily: 'Arial',
      id: `text-${Date.now()}`
    } as any)

    canvas.add(text)
    canvas.setActiveObject(text)
    updateObjectsList(canvas)
    toast.success('Texto adicionado!')
  }

  const addImage = () => {
    fileInputRef.current?.click()
  }

  const handleImageUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0]
    if (!file || !fabricCanvasRef.current) return

    const reader = new FileReader()
    reader.onload = (e) => {
      const imgUrl = e.target?.result as string
      fabric.Image.fromURL(imgUrl, (img) => {
        const canvas = fabricCanvasRef.current!
        
        // Scale image to fit canvas
        const maxWidth = canvas.width! * 0.5
        const maxHeight = canvas.height! * 0.5
        const scale = Math.min(maxWidth / img.width!, maxHeight / img.height!)
        
        img.set({
          left: 100,
          top: 100,
          scaleX: scale,
          scaleY: scale,
          id: `image-${Date.now()}`
        } as any)

        canvas.add(img)
        canvas.setActiveObject(img)
        updateObjectsList(canvas)
        toast.success('Imagem adicionada!')
      })
    }
    reader.readAsDataURL(file)
  }

  // Object manipulation
  const deleteSelected = () => {
    const canvas = fabricCanvasRef.current
    if (!canvas) return

    const activeObjects = canvas.getActiveObjects()
    if (activeObjects.length > 0) {
      canvas.remove(...activeObjects)
      canvas.discardActiveObject()
      updateObjectsList(canvas)
      toast.success(`${activeObjects.length} objeto(s) removido(s)`)
    }
  }

  const duplicateSelected = () => {
    const canvas = fabricCanvasRef.current
    if (!canvas) return

    const activeObject = canvas.getActiveObject()
    if (!activeObject) return

    activeObject.clone((cloned: fabric.Object) => {
      cloned.set({
        left: (cloned.left || 0) + 20,
        top: (cloned.top || 0) + 20,
        id: `clone-${Date.now()}`
      } as any)
      canvas.add(cloned)
      canvas.setActiveObject(cloned)
      updateObjectsList(canvas)
      toast.success('Objeto duplicado!')
    })
  }

  // Layer management
  const moveObjectUp = (objectId: string) => {
    const canvas = fabricCanvasRef.current
    if (!canvas) return

    const obj = canvas.getObjects().find(o => (o as any).id === objectId)
    if (obj) {
      canvas.bringForward(obj)
      updateObjectsList(canvas)
    }
  }

  const moveObjectDown = (objectId: string) => {
    const canvas = fabricCanvasRef.current
    if (!canvas) return

    const obj = canvas.getObjects().find(o => (o as any).id === objectId)
    if (obj) {
      canvas.sendBackwards(obj)
      updateObjectsList(canvas)
    }
  }

  const toggleObjectVisibility = (objectId: string) => {
    const canvas = fabricCanvasRef.current
    if (!canvas) return

    const obj = canvas.getObjects().find(o => (o as any).id === objectId)
    if (obj) {
      obj.visible = !obj.visible
      canvas.renderAll()
      updateObjectsList(canvas)
    }
  }

  const toggleObjectLock = (objectId: string) => {
    const canvas = fabricCanvasRef.current
    if (!canvas) return

    const obj = canvas.getObjects().find(o => (o as any).id === objectId)
    if (obj) {
      obj.selectable = !obj.selectable
      obj.evented = obj.selectable
      canvas.renderAll()
      updateObjectsList(canvas)
    }
  }

  // History management
  const undo = () => {
    if (!canUndo || historyIndex <= 0) return
    
    const canvas = fabricCanvasRef.current
    if (!canvas) return

    setHistoryIndex(prev => prev - 1)
    const previousState = history[historyIndex - 1]
    
    canvas.loadFromJSON(previousState, () => {
      canvas.renderAll()
      updateObjectsList(canvas)
      setCanUndo(historyIndex > 1)
      setCanRedo(true)
    })
  }

  const redo = () => {
    if (!canRedo || historyIndex >= history.length - 1) return
    
    const canvas = fabricCanvasRef.current
    if (!canvas) return

    setHistoryIndex(prev => prev + 1)
    const nextState = history[historyIndex + 1]
    
    canvas.loadFromJSON(nextState, () => {
      canvas.renderAll()
      updateObjectsList(canvas)
      setCanUndo(true)
      setCanRedo(historyIndex + 1 < history.length - 1)
    })
  }

  // Zoom functions
  const handleZoomChange = (value: number[]) => {
    const canvas = fabricCanvasRef.current
    if (!canvas) return

    const zoomLevel = value[0] / 100
    setZoom(value)
    canvas.setZoom(zoomLevel)
    canvas.renderAll()
  }

  const zoomToFit = () => {
    const canvas = fabricCanvasRef.current
    if (!canvas) return

    const objects = canvas.getObjects()
    if (objects.length === 0) return

    const group = new fabric.Group(objects)
    const bounds = group.getBoundingRect()
    
    const scaleX = canvas.width! / bounds.width
    const scaleY = canvas.height! / bounds.height
    const zoom = Math.min(scaleX, scaleY) * 0.8

    canvas.setZoom(zoom)
    setZoom([zoom * 100])
    canvas.renderAll()
  }

  // Export functions
  const exportCanvas = (format: 'png' | 'jpg' | 'svg' | 'json') => {
    const canvas = fabricCanvasRef.current
    if (!canvas) return

    switch (format) {
      case 'png':
        const pngUrl = canvas.toDataURL({ format: 'png', quality: 1 })
        downloadFile(pngUrl, `${projectName}.png`)
        break
      case 'jpg':
        const jpgUrl = canvas.toDataURL({ format: 'jpeg', quality: 0.9 })
        downloadFile(jpgUrl, `${projectName}.jpg`)
        break
      case 'svg':
        const svgData = canvas.toSVG()
        downloadFile(`data:image/svg+xml;charset=utf-8,${encodeURIComponent(svgData)}`, `${projectName}.svg`)
        break
      case 'json':
        const jsonData = JSON.stringify(canvas.toJSON(), null, 2)
        downloadFile(`data:application/json;charset=utf-8,${encodeURIComponent(jsonData)}`, `${projectName}.json`)
        break
    }
  }

  const downloadFile = (url: string, filename: string) => {
    const link = document.createElement('a')
    link.href = url
    link.download = filename
    link.click()
    toast.success(`${filename} exportado com sucesso!`)
  }

  // Handle tool selection
  const handleToolSelect = (toolId: string) => {
    setSelectedTool(toolId)
    
    switch (toolId) {
      case 'rect':
        addRectangle()
        break
      case 'circle':
        addCircle()
        break
      case 'text':
        addText()
        break
      case 'image':
        addImage()
        break
    }
  }

  return (
    <div className="flex h-screen bg-gray-50 dark:bg-gray-900">
      {/* Left Sidebar - Tools */}
      <div className="w-80 bg-white dark:bg-gray-800 border-r border-gray-200 dark:border-gray-700 flex flex-col">
        {/* Header */}
        <div className="p-4 border-b border-gray-200 dark:border-gray-700">
          <div className="flex items-center justify-between mb-4">
            <h2 className="text-lg font-semibold text-gray-900 dark:text-white">
              Canvas Editor
            </h2>
            <Badge variant="secondary" className="bg-blue-100 text-blue-700">
              Production Ready
            </Badge>
          </div>
          
          {/* Project Name */}
          <Input
            value={projectName}
            className="text-sm"
            placeholder="Nome do projeto"
            readOnly
          />
        </div>

        {/* Tools Tabs */}
        <Tabs defaultValue="tools" className="flex-1 flex flex-col">
          <TabsList className="grid w-full grid-cols-3 mx-4 mt-4">
            <TabsTrigger value="tools">Ferramentas</TabsTrigger>
            <TabsTrigger value="layers">Layers</TabsTrigger>
            <TabsTrigger value="export">Export</TabsTrigger>
          </TabsList>

          <TabsContent value="tools" className="flex-1 p-4 space-y-4">
            {/* Tool Selection */}
            <div>
              <Label className="text-sm font-medium mb-2 block">Ferramentas</Label>
              <div className="grid grid-cols-2 gap-2">
                {tools.map((tool) => {
                  const Icon = tool.icon
                  return (
                    <Button
                      key={tool.id}
                      variant={selectedTool === tool.id ? "default" : "outline"}
                      size="sm"
                      onClick={() => handleToolSelect(tool.id)}
                      className="flex items-center gap-2 text-xs"
                    >
                      <Icon className="h-4 w-4" />
                      {tool.label}
                    </Button>
                  )
                })}
              </div>
            </div>

            <Separator />

            {/* Canvas Controls */}
            <div className="space-y-4">
              <div>
                <Label className="text-sm font-medium mb-2 block">Zoom ({zoom[0]}%)</Label>
                <Slider
                  value={zoom}
                  onValueChange={handleZoomChange}
                  min={10}
                  max={500}
                  step={10}
                  className="w-full"
                />
                <div className="flex gap-2 mt-2">
                  <Button size="sm" variant="outline" onClick={zoomToFit}>
                    Ajustar Zoom
                  </Button>
                  <Button size="sm" variant="outline" onClick={() => handleZoomChange([100])}>
                    100%
                  </Button>
                </div>
              </div>

              <div className="flex items-center space-x-2">
                <input
                  type="checkbox"
                  id="snapToGrid"
                  checked={snapToGrid}
                  onChange={(e) => setSnapToGrid(e.target.checked)}
                  className="rounded"
                />
                <Label htmlFor="snapToGrid" className="text-sm">
                  Snap to Grid
                </Label>
              </div>

              {snapToGrid && (
                <div>
                  <Label className="text-sm font-medium mb-2 block">
                    Tamanho da Grade: {gridSize}px
                  </Label>
                  <Slider
                    value={[gridSize]}
                    onValueChange={(value) => setGridSize(value[0])}
                    min={5}
                    max={50}
                    step={5}
                    className="w-full"
                  />
                </div>
              )}
            </div>
          </TabsContent>

          <TabsContent value="layers" className="flex-1 p-4">
            <div className="space-y-2">
              <div className="flex items-center justify-between mb-4">
                <Label className="text-sm font-medium">Layers ({canvasObjects.length})</Label>
                <Button size="sm" variant="outline" onClick={() => updateObjectsList(fabricCanvasRef.current!)}>
                  <RotateCcw className="h-4 w-4" />
                </Button>
              </div>

              {canvasObjects.length === 0 ? (
                <div className="text-center py-8 text-gray-500 dark:text-gray-400">
                  <Layers className="h-8 w-8 mx-auto mb-2 opacity-50" />
                  <p className="text-sm">Nenhum objeto no canvas</p>
                </div>
              ) : (
                <div className="space-y-1 max-h-96 overflow-y-auto">
                  {canvasObjects.map((obj, index) => (
                    <Card key={obj.id} className={`p-2 cursor-pointer ${
                      selectedObjects.includes(obj.id) ? 'ring-2 ring-blue-500' : ''
                    }`}>
                      <div className="flex items-center justify-between">
                        <div className="flex items-center gap-2">
                          <div className={`w-3 h-3 rounded ${
                            obj.type === 'rect' ? 'bg-blue-500' :
                            obj.type === 'circle' ? 'bg-green-500' :
                            obj.type === 'text' ? 'bg-purple-500' :
                            obj.type === 'image' ? 'bg-orange-500' :
                            'bg-gray-500'
                          }`} />
                          <span className="text-xs font-medium truncate max-w-24">
                            {obj.name}
                          </span>
                        </div>
                        
                        <div className="flex gap-1">
                          <Button
                            size="sm"
                            variant="ghost"
                            onClick={() => toggleObjectVisibility(obj.id)}
                            className="h-6 w-6 p-0"
                          >
                            {obj.visible ? <Eye className="h-3 w-3" /> : <EyeOff className="h-3 w-3" />}
                          </Button>
                          <Button
                            size="sm"
                            variant="ghost"
                            onClick={() => toggleObjectLock(obj.id)}
                            className="h-6 w-6 p-0"
                          >
                            {obj.locked ? <Lock className="h-3 w-3" /> : <Unlock className="h-3 w-3" />}
                          </Button>
                        </div>
                      </div>
                      
                      <div className="flex gap-1 mt-2">
                        <Button
                          size="sm"
                          variant="ghost"
                          onClick={() => moveObjectUp(obj.id)}
                          className="h-6 px-2 text-xs"
                        >
                          â†‘
                        </Button>
                        <Button
                          size="sm"
                          variant="ghost"
                          onClick={() => moveObjectDown(obj.id)}
                          className="h-6 px-2 text-xs"
                        >
                          â†“
                        </Button>
                      </div>
                    </Card>
                  ))}
                </div>
              )}
            </div>
          </TabsContent>

          <TabsContent value="export" className="flex-1 p-4">
            <div className="space-y-4">
              <Label className="text-sm font-medium">Exportar Canvas</Label>
              
              <div className="grid grid-cols-2 gap-2">
                <Button
                  size="sm"
                  variant="outline"
                  onClick={() => exportCanvas('png')}
                  className="flex items-center gap-2"
                >
                  <Download className="h-4 w-4" />
                  PNG
                </Button>
                <Button
                  size="sm"
                  variant="outline"
                  onClick={() => exportCanvas('jpg')}
                  className="flex items-center gap-2"
                >
                  <Download className="h-4 w-4" />
                  JPG
                </Button>
                <Button
                  size="sm"
                  variant="outline"
                  onClick={() => exportCanvas('svg')}
                  className="flex items-center gap-2"
                >
                  <Download className="h-4 w-4" />
                  SVG
                </Button>
                <Button
                  size="sm"
                  variant="outline"
                  onClick={() => exportCanvas('json')}
                  className="flex items-center gap-2"
                >
                  <FileText className="h-4 w-4" />
                  JSON
                </Button>
              </div>

              <Separator />

              <div>
                <Label className="text-sm font-medium mb-2 block">Canvas Info</Label>
                <div className="text-xs text-gray-600 dark:text-gray-400 space-y-1">
                  <p>Tamanho: {width}Ã—{height}px</p>
                  <p>Objetos: {canvasObjects.length}</p>
                  <p>Zoom: {zoom[0]}%</p>
                  <p>Grade: {snapToGrid ? `${gridSize}px` : 'Desabilitada'}</p>
                </div>
              </div>
            </div>
          </TabsContent>
        </Tabs>
      </div>

      {/* Main Canvas Area */}
      <div className="flex-1 flex flex-col">
        {/* Top Toolbar */}
        <div className="bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 p-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <Button
                size="sm"
                variant="outline"
                onClick={undo}
                disabled={!canUndo}
                className="flex items-center gap-1"
              >
                <RotateCcw className="h-4 w-4" />
                Desfazer
              </Button>
              <Button
                size="sm"
                variant="outline"
                onClick={redo}
                disabled={!canRedo}
                className="flex items-center gap-1"
              >
                <RotateCw className="h-4 w-4" />
                Refazer
              </Button>
              
              <Separator orientation="vertical" className="h-6" />
              
              <Button
                size="sm"
                variant="outline"
                onClick={duplicateSelected}
                disabled={selectedObjects.length === 0}
                className="flex items-center gap-1"
              >
                <Copy className="h-4 w-4" />
                Duplicar
              </Button>
              <Button
                size="sm"
                variant="destructive"
                onClick={deleteSelected}
                disabled={selectedObjects.length === 0}
                className="flex items-center gap-1"
              >
                <Trash2 className="h-4 w-4" />
                Excluir
              </Button>
            </div>

            <div className="flex items-center gap-2">
              <Badge variant="secondary" className="text-xs">
                {selectedObjects.length} selecionado(s)
              </Badge>
              <Button size="sm" variant="outline" className="flex items-center gap-1">
                <Settings className="h-4 w-4" />
                Config
              </Button>
            </div>
          </div>
        </div>

        {/* Canvas Container */}
        <div className="flex-1 overflow-auto bg-gray-100 dark:bg-gray-900 p-8">
          <div className="flex justify-center">
            <div className="relative bg-white shadow-lg">
              <canvas
                ref={canvasRef}
                className="border border-gray-300 dark:border-gray-600"
              />
              
              {/* Grid overlay when enabled */}
              {snapToGrid && (
                <div
                  className="absolute inset-0 pointer-events-none opacity-20"
                  style={{
                    backgroundImage: `
                      linear-gradient(to right, #e5e7eb 1px, transparent 1px),
                      linear-gradient(to bottom, #e5e7eb 1px, transparent 1px)
                    `,
                    backgroundSize: `${gridSize}px ${gridSize}px`
                  }}
                />
              )}
            </div>
          </div>
        </div>

        {/* Status Bar */}
        <div className="bg-white dark:bg-gray-800 border-t border-gray-200 dark:border-gray-700 px-4 py-2">
          <div className="flex items-center justify-between text-xs text-gray-600 dark:text-gray-400">
            <div className="flex items-center gap-4">
              <span>Canvas: {width}Ã—{height}px</span>
              <span>Zoom: {zoom[0]}%</span>
              <span>Objetos: {canvasObjects.length}</span>
            </div>
            <div className="flex items-center gap-4">
              <span>Tool: {tools.find(t => t.id === selectedTool)?.label}</span>
              <span>Snap: {snapToGrid ? 'ON' : 'OFF'}</span>
            </div>
          </div>
        </div>
      </div>

      {/* Hidden file input for image upload */}
      <input
        ref={fileInputRef}
        type="file"
        accept="image/*"
        className="hidden"
        onChange={handleImageUpload}
      />
    </div>
  )
}
        }
      })
    }
    
    // Track object selection
    canvas.on('selection:created', updateObjectsList)
    canvas.on('selection:updated', updateObjectsList)
    canvas.on('selection:cleared', updateObjectsList)
    canvas.on('object:added', updateObjectsList)
    canvas.on('object:removed', updateObjectsList)
    
    fabricCanvasRef.current = canvas
    
    // Load initial data
    if (initialData) {
      canvas.loadFromJSON(initialData, () => {
        canvas.renderAll()
        updateObjectsList()
      })
    }
    
    return () => {
      canvas.dispose()
      fabricCanvasRef.current = null
    }
  }, [width, height, snapToGrid, initialData])
  
  // Update objects list
  const updateObjectsList = useCallback(() => {
    if (!fabricCanvasRef.current) return
    
    const objects = fabricCanvasRef.current.getObjects().map((obj: any, index: number) => ({
      id: obj.id || `object_${index}`,
      type: obj.type || 'unknown',
      name: obj.name || `${obj.type} ${index + 1}`,
      visible: obj.visible !== false,
      locked: obj.selectable === false
    }))
    
    setCanvasObjects(objects)
    
    // Notify parent component
    if (onCanvasUpdate) {
      onCanvasUpdate({
        objects: objects.length,
        json: fabricCanvasRef.current.toJSON()
      })
    }
  }, [onCanvasUpdate])
  
  // Tool handlers
  const addRectangle = () => {
    if (!fabricCanvasRef.current) return
    
    const rect = new fabric.Rect({
      left: 100,
      top: 100,
      fill: '#3b82f6',
      width: 120,
      height: 80,
      name: `Rectangle ${canvasObjects.length + 1}`
    })
    
    fabricCanvasRef.current.add(rect)
    fabricCanvasRef.current.setActiveObject(rect)
  }
  
  const addCircle = () => {
    if (!fabricCanvasRef.current) return
    
    const circle = new fabric.Circle({
      left: 150,
      top: 150,
      fill: '#10b981',
      radius: 50,
      name: `Circle ${canvasObjects.length + 1}`
    })
    
    fabricCanvasRef.current.add(circle)
    fabricCanvasRef.current.setActiveObject(circle)
  }
  
  const addText = () => {
    if (!fabricCanvasRef.current) return
    
    const text = new fabric.IText('Clique para editar', {
      left: 200,
      top: 200,
      fontFamily: 'Arial',
      fontSize: 20,
      fill: '#1f2937',
      name: `Text ${canvasObjects.length + 1}`
    })
    
    fabricCanvasRef.current.add(text)
    fabricCanvasRef.current.setActiveObject(text)
  }
  
  const deleteSelected = () => {
    if (!fabricCanvasRef.current) return
    
    const activeObjects = fabricCanvasRef.current.getActiveObjects()
    activeObjects.forEach(obj => {
      fabricCanvasRef.current!.remove(obj)
    })
    fabricCanvasRef.current.discardActiveObject()
  }
  
  const duplicateSelected = () => {
    if (!fabricCanvasRef.current) return
    
    const activeObject = fabricCanvasRef.current.getActiveObject()
    if (!activeObject) return
    
    try {
      const cloned = (fabric as any).util.object.clone(activeObject)
      cloned.set({
        left: cloned.left + 20,
        top: cloned.top + 20
      })
      fabricCanvasRef.current.add(cloned)
      fabricCanvasRef.current.setActiveObject(cloned)
    } catch (error) {
      console.log('Error duplicating object:', error)
    }
  }
  
  const handleZoom = (newZoom: number[]) => {
    if (!fabricCanvasRef.current) return
    
    const zoomLevel = newZoom[0] / 100
    setZoom(newZoom)
    fabricCanvasRef.current.setZoom(zoomLevel)
    fabricCanvasRef.current.renderAll()
  }
  
  const exportCanvas = () => {
    if (!fabricCanvasRef.current) return
    
    const dataURL = fabricCanvasRef.current.toDataURL({
      format: 'png',
      quality: 1,
      multiplier: 1
    })
    
    const link = document.createElement('a')
    link.download = 'canvas-export.png'
    link.href = dataURL
    link.click()
  }
  
  const clearCanvas = () => {
    if (!fabricCanvasRef.current) return
    fabricCanvasRef.current.clear()
    fabricCanvasRef.current.backgroundColor = '#ffffff'
  }
  
  return (
    <div className="flex h-full">
      {/* Toolbar */}
      <Card className="w-64 mr-4">
        <CardHeader>
          <CardTitle className="text-lg flex items-center space-x-2">
            <Palette className="h-5 w-5" />
            <span>Canvas Tools</span>
          </CardTitle>
        </CardHeader>
        
        <CardContent className="space-y-4">
          {/* Tool Selection */}
          <div className="space-y-2">
            <h4 className="font-semibold text-sm">Ferramentas</h4>
            <div className="grid grid-cols-2 gap-2">
              <Button
                variant={selectedTool === 'select' ? 'default' : 'outline'}
                size="sm"
                onClick={() => setSelectedTool('select')}
              >
                <MousePointer2 className="h-4 w-4" />
              </Button>
              <Button
                variant={selectedTool === 'move' ? 'default' : 'outline'}
                size="sm"
                onClick={() => setSelectedTool('move')}
              >
                <Move className="h-4 w-4" />
              </Button>
            </div>
          </div>
          
          <Separator />
          
          {/* Shape Tools */}
          <div className="space-y-2">
            <h4 className="font-semibold text-sm">Formas</h4>
            <div className="space-y-2">
              <Button
                variant="outline"
                size="sm"
                onClick={addRectangle}
                className="w-full justify-start"
              >
                <Square className="h-4 w-4 mr-2" />
                RetÃ¢ngulo
              </Button>
              <Button
                variant="outline"
                size="sm"
                onClick={addCircle}
                className="w-full justify-start"
              >
                <Circle className="h-4 w-4 mr-2" />
                CÃ­rculo
              </Button>
              <Button
                variant="outline"
                size="sm"
                onClick={addText}
                className="w-full justify-start"
              >
                <Type className="h-4 w-4 mr-2" />
                Texto
              </Button>
            </div>
          </div>
          
          <Separator />
          
          {/* Object Actions */}
          <div className="space-y-2">
            <h4 className="font-semibold text-sm">AÃ§Ãµes</h4>
            <div className="space-y-2">
              <Button
                variant="outline"
                size="sm"
                onClick={duplicateSelected}
                className="w-full justify-start"
              >
                <Copy className="h-4 w-4 mr-2" />
                Duplicar
              </Button>
              <Button
                variant="outline"
                size="sm"
                onClick={deleteSelected}
                className="w-full justify-start text-red-600"
              >
                <Trash2 className="h-4 w-4 mr-2" />
                Excluir
              </Button>
            </div>
          </div>
          
          <Separator />
          
          {/* Zoom Control */}
          <div className="space-y-2">
            <h4 className="font-semibold text-sm">Zoom: {zoom[0]}%</h4>
            <Slider
              value={zoom}
              onValueChange={handleZoom}
              min={25}
              max={300}
              step={25}
              className="w-full"
            />
            <div className="flex space-x-1">
              <Button
                variant="outline"
                size="sm"
                onClick={() => handleZoom([zoom[0] - 25])}
              >
                <ZoomOut className="h-4 w-4" />
              </Button>
              <Button
                variant="outline"
                size="sm"
                onClick={() => handleZoom([100])}
                className="flex-1"
              >
                100%
              </Button>
              <Button
                variant="outline"
                size="sm"
                onClick={() => handleZoom([zoom[0] + 25])}
              >
                <ZoomIn className="h-4 w-4" />
              </Button>
            </div>
          </div>
          
          <Separator />
          
          {/* Export */}
          <div className="space-y-2">
            <Button
              onClick={exportCanvas}
              className="w-full"
            >
              <Download className="h-4 w-4 mr-2" />
              Exportar PNG
            </Button>
          </div>
        </CardContent>
      </Card>
      
      {/* Canvas Area */}
      <div className="flex-1 flex flex-col">
        {/* Canvas Header */}
        <div className="mb-4 flex items-center justify-between">
          <div className="flex items-center space-x-2">
            <Badge variant="secondary">
              <Layers className="h-3 w-3 mr-1" />
              {canvasObjects.length} objetos
            </Badge>
            <Badge variant="outline">
              {width} x {height}
            </Badge>
          </div>
          
          <div className="flex items-center space-x-2">
            <Button
              variant={snapToGrid ? 'default' : 'outline'}
              size="sm"
              onClick={() => setSnapToGrid(!snapToGrid)}
            >
              <Grid className="h-4 w-4 mr-1" />
              Grid
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={clearCanvas}
            >
              Limpar
            </Button>
          </div>
        </div>
        
        {/* Canvas Container */}
        <div className="flex-1 border rounded-lg overflow-auto bg-gray-50 p-4">
          <div className="relative inline-block">
            {snapToGrid && (
              <div 
                className="absolute inset-0 pointer-events-none"
                style={{
                  backgroundImage: 'radial-gradient(circle, #ccc 1px, transparent 1px)',
                  backgroundSize: '10px 10px'
                }}
              />
            )}
            <canvas ref={canvasRef} className="border border-gray-300 bg-white" />
          </div>
        </div>
      </div>
    </div>
  )
}

