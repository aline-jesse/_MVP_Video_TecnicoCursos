

import { NextRequest, NextResponse } from 'next/server'
import { avatar3DLibrary, avatar3DRenderer } from '../../../../lib/avatars/avatar-3d-system'

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    
    const { 
      avatar_id,
      text,
      voice_settings,
      animation_config,
      scene_settings
    } = body

    // Validate required parameters
    if (!avatar_id || !text) {
      return NextResponse.json(
        { error: 'Avatar ID and text are required' },
        { status: 400 }
      )
    }

    // Get avatar configuration
    const avatarConfig = avatar3DLibrary.getAvatar(avatar_id)
    if (!avatarConfig) {
      return NextResponse.json(
        { error: `Avatar ${avatar_id} not found` },
        { status: 404 }
      )
    }

    // Prepare scene configuration
    const sceneConfig = {
      avatar_id,
      position: scene_settings?.position || { 
        x: 0, y: 0, z: 0, scale: avatarConfig.default_scale 
      },
      animation: {
        entry: animation_config?.entry || 'fade-in',
        idle: animation_config?.idle || 'breathing',
        speaking: animation_config?.speaking || 'natural-gestures',
        exit: animation_config?.exit || 'fade-out'
      },
      audio: {
        voice_id: voice_settings?.voice_id || avatarConfig.default_voice,
        text,
        emotion: voice_settings?.emotion || 'neutral',
        speed: voice_settings?.speed || 1.0,
        pitch: voice_settings?.pitch || 1.0
      },
      timing: {
        entry_time: 0.5,
        speak_start: 1.0,
        speak_duration: Math.max(3.0, text.length * 0.1), // Estimate based on text length
        exit_time: 0.5
      }
    }

    // Generate TTS audio first
    const audioResponse = await fetch('/api/tts/google', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        text,
        voice: sceneConfig.audio.voice_id,
        speed: sceneConfig.audio.speed,
        pitch: sceneConfig.audio.pitch
      })
    })

    if (!audioResponse.ok) {
      throw new Error('Failed to generate TTS audio')
    }

    const audioData = await audioResponse.arrayBuffer()

    // Load avatar if not already loaded
    await avatar3DRenderer.loadAvatar(avatarConfig)

    // Render avatar with lip-sync
    const videoUrl = await avatar3DRenderer.renderWithLipSync(sceneConfig, audioData)

    // Apply character consistency if multiple scenes
    if (scene_settings?.maintain_consistency) {
      await avatar3DRenderer.applyCharacterConsistency(avatar_id, [scene_settings.scene_id])
    }

    return NextResponse.json({
      success: true,
      data: {
        video_url: videoUrl,
        avatar_config: avatarConfig,
        scene_config: sceneConfig,
        audio_duration: sceneConfig.timing.speak_duration,
        total_duration: sceneConfig.timing.speak_duration + sceneConfig.timing.entry_time + sceneConfig.timing.exit_time,
        sync_quality: 0.92, // Simulated high quality
        processing_time: 5.5 // Simulated processing time
      }
    })

  } catch (error) {
    console.error('3D avatar render error:', error)
    
    return NextResponse.json(
      { 
        error: 'Failed to render 3D avatar',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    )
  }
}

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const type = searchParams.get('type')
    const profession = searchParams.get('profession')
    const gender = searchParams.get('gender')
    const isPremium = searchParams.get('premium')

    let avatars = avatar3DLibrary.getAllAvatars()

    // Apply filters
    if (type || profession || gender || isPremium) {
      avatars = avatar3DLibrary.searchAvatars({
        type: type as any,
        profession: profession || undefined,
        gender: gender as any,
        is_premium: isPremium === 'true' ? true : isPremium === 'false' ? false : undefined
      })
    }

    return NextResponse.json({
      success: true,
      data: {
        avatars: avatars.map(avatar => ({
          ...avatar,
          // Remove internal URLs for security
          model_url: avatar.model_url.replace('/avatars/3d/', '/api/avatars/models/'),
          texture_urls: avatar.texture_urls.map(url => 
            url.replace('/avatars/textures/', '/api/avatars/textures/')
          )
        })),
        total: avatars.length,
        types_available: ['realistic', 'cartoon', 'mascot'],
        professions_available: ['instructor', 'engineer', 'supervisor', 'worker', 'mascot'],
        voice_options: [
          'google-pt-BR-Neural2-A', 'google-pt-BR-Neural2-B', 
          'google-pt-BR-Neural2-C', 'google-pt-BR-Neural2-D'
        ]
      }
    })

  } catch (error) {
    console.error('Error getting avatars:', error)
    return NextResponse.json(
      { error: 'Failed to get avatar list' },
      { status: 500 }
    )
  }
}
